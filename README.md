# A Flexible Recipe for Deployment to Multiple Environments Using Pulumi, Kubernetes and Github Actions
The following is a recipe for managing and testing application deployments in different environments (local, staging, feature branch). 

## Key Features
- Local deployment recipe
- AWS deployment recipe

## Prerequisites
- [AWS account](https://aws.amazon.com/account/)
- [Cloudflare account](https://www.cloudflare.com/en-ca/)
- [Github account](https://github.com)
- [Pulumi account](https://www.pulumi.com/)
- [Pulumi installation](https://www.pulumi.com/docs/get-started/kubernetes/begin/)

## Tools
- [Certmanager](https://github.com/cert-manager/cert-manager) and [Let's Encrypt](https://letsencrypt.org/) to manage SSL certifications
- [Cloudflare](https://www.cloudflare.com/en-ca/) for domain management
- [Earthly](https://earthly.dev/) for reproducible builds
- [Elixir](https://elixir-lang.org/) and [Phoenix](https://www.phoenixframework.org/) for the demo application
- [Github Actions](https://github.com/features/actions) to trigger deployments on different branches
- [Github Container Registry](https://docs.github.com/en/packages/working-with-a-github-packages-registry/working-with-the-container-registry) to save Docker images
- [Minikube](https://minikube.sigs.k8s.io/docs/start/) to Kubernetes clusters locally 
- [Nginx](https://www.nginx.com/) as the reverse proxy
- [Pulumi](https://www.pulumi.com/) for instrastructure as code
- [Postgres](https://www.postgresql.org/) as the database inside the Kubernetes cluster

## Comments/Questions
Please open an issue or a discussion or send me a message on [Twitter](https://twitter.com/vinnerroy).

## Usage
Start by running `pulumi new kubernetes-typescript` inside your project which will generate scaffold in the folder of your choice and then use `Earthfile` and files inside the `deployment` folder to augment your app. The contents inside `deployment` were first generated by running `pulumi new kubernetes-typescript` inside an `deployment` folder.

## Local Deployment
You might want to call your [Pulumi stack](https://www.pulumi.com/docs/intro/concepts/stack/) something like `local` for this use-case.

By default, kubectl gets configured to access the kubernetes cluster control plane inside minikube when the `minikube start` command is run.
To resync the kubeconfig setup to connect to minikube, use `minikube update-context`

A `isMinikube` config variable is used to differenriate between local and remote deployments
`pulumi config set isMinikube false`

### Load Balancer
The Pulumi docs state that Minikube does not support the `LoadBalancer` service type, but this is no longer true as per [Minikube's docs](https://minikube.sigs.k8s.io/docs/handbook/accessing/#loadbalancer-access)
However, you must run: `minikube tunnel` before `pulumi up` for the load balancer service-type to work.
If you run into a problem with the Minikube tunnel, you can use `minikube tunnel --cleanup` to clean up orphaned processes before starting a tnnel.
Use `kubectl get svc` to get the IP to access the service.

### Clean up
Use `pulumi destroy` to destroy the cluster and optionally use `pulumi stack rm` to delete the stack history from Pulumi's servers.

## Production Deployment
You might want to call your [Pulumi stack](https://www.pulumi.com/docs/intro/concepts/stack/) something like `production` for this use-case.

Work in progress...

## Beta Deployment
You might want to call your [Pulumi stack](https://www.pulumi.com/docs/intro/concepts/stack/) something like `beta` for this use-case.

Work in progress...

## Feature Branch/PR Deployment
You probably want to name your [Pulumi stack](https://www.pulumi.com/docs/intro/concepts/stack/) automatically based on the branch name for this use-case.

Work in progress...
